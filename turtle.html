<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Cadets Turtle</title>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>

  <style>
    body { margin:0; padding:14px; font-family:system-ui; }
    h3 { margin:0 0 12px 0; }

    #layout {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
    }

    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; }
      canvas { width: 100%; height: auto; }
    }

    /* =============================
       CodeMirror – ebook-matching
       (tight line spacing + green imports)
       ============================= */

    .CodeMirror {
      height: 280px;
      border-radius: 12px;
      border: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset;

      /* IMPORTANT: override defaults to fix huge line gaps */
      line-height: 1.25;
    }

    .cm-s-ccbook.CodeMirror {
      background: #2b2f3a;
      color: #e9eef7;
    }

    /* Reduce extra vertical padding that makes line 2 drop */
    .cm-s-ccbook .CodeMirror-lines { padding: 8px 0; }

    /* Force internal <pre> + line boxes to obey our line height */
    .cm-s-ccbook .CodeMirror-line,
    .cm-s-ccbook .CodeMirror pre {
      padding: 0 10px;
      line-height: 1.25;
    }

    /* Cursor size to match line height */
    .cm-s-ccbook .CodeMirror-cursor {
      border-left: 2px solid #ffffff !important;
      height: 1.25em !important;
    }

    .cm-s-ccbook .CodeMirror-selected {
      background: rgba(255,255,255,0.10) !important;
    }

    /* Gutter + line numbers */
    .cm-s-ccbook .CodeMirror-gutters {
      background: #262a34;
      border-right: 0;
    }
    .cm-s-ccbook .CodeMirror-linenumber {
      color: #7fd0c1;
      opacity: 0.75;
    }

    /* Syntax colours */
    .cm-s-ccbook .cm-keyword { color: #ff4fd8; } /* pink keywords */
    .cm-s-ccbook .cm-variable { color: #e9eef7; } /* default identifiers */
    .cm-s-ccbook .cm-builtin { color: #cbd5e1; }
    .cm-s-ccbook .cm-string  { color: #bfe8ff; }
    .cm-s-ccbook .cm-number  { color: #ffd479; }
    .cm-s-ccbook .cm-comment { color: #a7b0c0; opacity: 0.75; }

    /* ✅ Make imported module names green (ebook style)
       - 'from turtle import *' => turtle green
       - 'import time' => time green
    */
    .cm-s-ccbook .cm-keyword + .cm-variable,
    .cm-s-ccbook .cm-keyword + .cm-builtin {
      color: #4cff9b;
    }

    /* Catch common Python mode classifications for imports */
    .cm-s-ccbook span.cm-builtin {
      color: #4cff9b;
    }

    /* =============================
       Rest of UI
       ============================= */

    canvas { background:#fff; border:1px solid #ccc; border-radius:10px; }

    button {
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      cursor:pointer;
    }
    button.secondary { border:1px solid #999; background:#fff; color:#111; }
    button:disabled { opacity:0.5; cursor:not-allowed; }

    #toolbar { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; align-items:center; }
    #status { font-size:14px; }

    .panelTitle { font-size:12px; margin:10px 0 6px 0; color:#374151; }

    pre {
      white-space: pre-wrap;
      background: #ffffff;
      color: #111111;
      padding: 10px;
      border-radius: 10px;
      margin: 0;
      min-height: 90px;
      border: 1px solid #d1d5db;
    }
    pre.err { background: #fff6f6; color: #7f1d1d; border: 1px solid #f0c0c0; }
  </style>
</head>

<body>
  <h3>Code Cadets – Python Turtle</h3>

  <div id="layout">
    <div>
      <textarea id="code" spellcheck="false">from turtle import *
import time</textarea>

      <div id="toolbar">
        <button id="run" disabled>Run</button>
        <button id="toggleLines" class="secondary" disabled>Line numbers: ON</button>
        <button id="clearCanvas" class="secondary">Clear canvas</button>
        <button id="clearOut" class="secondary">Clear output</button>
        <span id="status">Loading Python…</span>
      </div>

      <div class="panelTitle">Output</div>
      <pre id="out"></pre>

      <div class="panelTitle">Errors</div>
      <pre id="err" class="err"></pre>
    </div>

    <canvas id="canvas" width="520" height="520"></canvas>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const errEl = document.getElementById("err");

  const runBtn = document.getElementById("run");
  const toggleLinesBtn = document.getElementById("toggleLines");
  const clearCanvasBtn = document.getElementById("clearCanvas");
  const clearOutBtn = document.getElementById("clearOut");

  // ---------- CodeMirror ----------
  const editor = CodeMirror.fromTextArea(document.getElementById("code"), {
    mode: "python",
    theme: "ccbook",
    lineNumbers: true,
    indentUnit: 2,
    tabSize: 2,
    viewportMargin: Infinity
  });
  editor.getWrapperElement().classList.add("cm-s-ccbook");

  let linesOn = true;
  toggleLinesBtn.onclick = () => {
    linesOn = !linesOn;
    editor.setOption("lineNumbers", linesOn);
    toggleLinesBtn.textContent = `Line numbers: ${linesOn ? "ON" : "OFF"}`;
    editor.refresh();
  };

  clearOutBtn.onclick = () => { outEl.textContent = ""; errEl.textContent = ""; };

  // ---------- Turtle state ----------
  const cx = () => canvas.width / 2;
  const cy = () => canvas.height / 2;

  let x = cx();
  let y = cy();
  let angle = 0;
  let penDown = true;

  let penColor = "#000000";
  let fillColor = "#000000";
  let penSize = 2;
  let isFilling = false;

  let bgColor = "#ffffff";

  let delayMs = 10;
  let tracerN = 1;
  let tracerDelayMs = null;

  let queue = [];

  function applyCanvasBackground(){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function resetTurtle(keepBg = true){
    x = cx(); y = cy(); angle = 0; penDown = true;
    penColor = "#000000"; fillColor = "#000000"; penSize = 2; isFilling = false;

    delayMs = 10; tracerN = 1; tracerDelayMs = null;
    queue = [];

    if (!keepBg) bgColor = "#ffffff";

    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    applyCanvasBackground();
  }

  function clearCanvasAll(){
    bgColor = "#ffffff";
    resetTurtle(true);
  }
  clearCanvasBtn.onclick = () => { clearCanvasAll(); };

  // ---------- Queue helpers ----------
  function q(type, value){ queue.push([type, value]); }

  // Turtle API (queued)
  function update(){ q("update"); }
  function hideturtle(){ q("noop"); }
  function showturtle(){ q("noop"); }

  function forward(dist){ q("forward", Number(dist) || 0); }
  function backward(dist){ q("forward", -(Number(dist) || 0)); }
  function back(dist){ backward(dist); }

  function left(deg){ q("left", Number(deg) || 0); }
  function right(deg){ q("right", Number(deg) || 0); }

  function penup(){ q("penup"); }
  function pendown(){ q("pendown"); }

  function pu(){ penup(); }
  function pd(){ pendown(); }
  function fd(d){ forward(d); }
  function bk(d){ backward(d); }
  function rt(a){ right(a); }
  function lt(a){ left(a); }

  function pencolor(c){ q("pencolor", c); }
  function color(c){ q("pencolor", c); }
  function pensize(s){ q("pensize", Number(s) || 1); }
  function width(s){ q("pensize", Number(s) || 1); }

  function fillcolor(c){ q("fillcolor", c); }
  function begin_fill(){ q("begin_fill"); }
  function end_fill(){ q("end_fill"); }

  function goto_(tx, ty){ q("goto", [Number(tx) || 0, Number(ty) || 0]); }

  function dot(size, c){
    q("dot", {
      size: (size === undefined || size === null) ? 10 : Number(size) || 10,
      color: (c === undefined || c === null) ? null : c
    });
  }

  function bgcolor(c){ q("bgcolor", c); }

  function circle(radius, extent, steps){
    q("circle", {
      radius: Number(radius) || 0,
      extent: (extent === undefined) ? 360 : Number(extent) || 0,
      steps: (steps === undefined || steps === null) ? null : (Number(steps) || null),
    });
  }

  function speed(s){ q("speed", Number(s)); }

  function tracer(n, d){
    q("tracer", {
      n: (n === undefined || n === null) ? 1 : Number(n),
      delay: (d === undefined || d === null) ? null : Number(d)
    });
  }

  function home(){ q("home"); }
  function clear_(){ q("clear"); }

  function Screen(){
    return { bgcolor: (c) => bgcolor(c) };
  }

  // ---------- Coordinate helpers ----------
  function toCanvasX(tx){ return cx() + tx; }
  function toCanvasY(ty){ return cy() - ty; }

  function maybeDelay(stepIndex){
    const effectiveTracer = (tracerN === 0 ? 1 : tracerN);
    const effectiveDelay = (tracerDelayMs !== null) ? tracerDelayMs : delayMs;

    if (effectiveTracer > 1 && (stepIndex % effectiveTracer) !== 0) return Promise.resolve();
    if (!effectiveDelay || effectiveDelay <= 0) return Promise.resolve();
    return new Promise(r => setTimeout(r, effectiveDelay));
  }

  async function drawLineTo(nx, ny, stepIndex){
    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;

    if (penDown){
      if (isFilling){
        ctx.lineTo(nx, ny);
      } else {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nx, ny);
        ctx.stroke();
      }
    }

    x = nx; y = ny;
    await maybeDelay(stepIndex);
  }

  async function moveForwardAnimated(dist){
    const steps = Math.max(1, Math.min(4000, Math.round(Math.abs(dist))));
    const stepSize = dist / steps;

    for (let i = 1; i <= steps; i++){
      const rad = angle * Math.PI / 180;
      const nx = x + Math.cos(rad) * stepSize;
      const ny = y - Math.sin(rad) * stepSize;
      await drawLineTo(nx, ny, i);
    }
  }

  async function moveGotoAnimated(tx, ty){
    const nx = toCanvasX(tx);
    const ny = toCanvasY(ty);

    const dx = nx - x;
    const dy = ny - y;
    const dist = Math.hypot(dx, dy);

    const steps = Math.max(1, Math.min(4000, Math.round(dist)));
    const sx = dx / steps;
    const sy = dy / steps;

    for (let i = 1; i <= steps; i++){
      await drawLineTo(x + sx, y + sy, i);
    }
  }

  async function circleAnimated(spec){
    const radius = spec.radius || 0;
    const extent = (spec.extent === undefined) ? 360 : spec.extent;
    const steps = spec.steps;

    const n = (steps !== null && steps !== undefined)
      ? Math.max(4, Math.min(720, Math.round(steps)))
      : Math.max(24, Math.min(240, Math.round(Math.abs(extent) * 0.5)));

    const stepAngle = extent / n;
    const arcLen = (2 * Math.PI * Math.abs(radius)) * (Math.abs(stepAngle) / 360);

    const turnDir = (radius >= 0) ? 1 : -1;
    const dist = arcLen;

    for (let i = 1; i <= n; i++){
      await moveForwardAnimated(dist);
      angle += turnDir * stepAngle;
    }
  }

  function applySpeed(s){
    const n = Number.isFinite(s) ? Math.max(0, Math.min(10, Math.round(s))) : 3;
    if (n === 0) delayMs = 2;
    else delayMs = Math.max(1, 32 - (n * 3));
  }

  // ---------- Queue runner ----------
  async function runQueue(stopOnUpdate){
    while (queue.length){
      const [type, value] = queue.shift();

      if (type === "noop") { /* nothing */ }
      else if (type === "update") { if (stopOnUpdate) return; }

      else if (type === "left") { angle += value; }
      else if (type === "right") { angle -= value; }
      else if (type === "penup") { penDown = false; }
      else if (type === "pendown") { penDown = true; }

      else if (type === "pencolor") { penColor = String(value ?? penColor); }
      else if (type === "fillcolor") { fillColor = String(value ?? fillColor); }
      else if (type === "pensize") { penSize = Math.max(1, Math.min(50, value || 1)); }

      else if (type === "speed") { applySpeed(value); }

      else if (type === "tracer") {
        const n = value?.n;
        const d = value?.delay;

        tracerN = (Number.isFinite(n) ? n : 1);
        tracerN = Math.max(0, Math.min(50, Math.round(tracerN)));

        tracerDelayMs = (d === null || d === undefined) ? null : Math.max(0, Math.min(2000, Math.round(d)));
      }

      else if (type === "begin_fill") {
        isFilling = true;
        ctx.beginPath();
        ctx.moveTo(x, y);
      }

      else if (type === "end_fill") {
        if (isFilling){
          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          if (penDown){
            ctx.lineWidth = penSize;
            ctx.strokeStyle = penColor;
            ctx.stroke();
          }
        }
        isFilling = false;
      }

      else if (type === "home") {
        await moveGotoAnimated(0, 0);
        angle = 0;
      }

      else if (type === "clear") {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        applyCanvasBackground();
        x = cx(); y = cy(); angle = 0;
        isFilling = false;
      }

      else if (type === "bgcolor") {
        bgColor = String(value ?? bgColor);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        applyCanvasBackground();
      }

      else if (type === "goto") {
        const tx = value[0], ty = value[1];
        await moveGotoAnimated(tx, ty);
      }

      else if (type === "circle") {
        await circleAnimated(value);
      }

      else if (type === "forward") {
        await moveForwardAnimated(value);
      }

      else if (type === "dot") {
        const size = Math.max(1, Math.min(600, Number(value.size) || 10));
        const c = value.color;
        const oldFill = ctx.fillStyle;

        ctx.beginPath();
        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = (c === null || c === undefined) ? penColor : String(c);
        ctx.fill();

        ctx.fillStyle = oldFill;
        await maybeDelay(1);
      }
    }
  }

  window._cc_flush = async () => { await runQueue(true); };

  // ---------- Pyodide boot + Python I/O ----------
  let pyodide = null;

  async function main(){
    try{
      statusEl.textContent = "Loading Python…";
      pyodide = await loadPyodide();

      window._cc_append = (s) => { outEl.textContent += String(s); };
      window._cc_input = (promptText) => (window.prompt(String(promptText ?? "")) || "");

      pyodide.runPython(`
import sys, js, builtins

class _CCWriter:
    def write(self, s): js._cc_append(s)
    def flush(self): pass

sys.stdout = _CCWriter()
sys.stderr = _CCWriter()

builtins.input = lambda prompt="": js._cc_input(prompt)
      `.trim());

      pyodide.registerJsModule("cc_turtle", {
        update,
        forward, backward, back, left, right,
        penup, pendown, pu, pd, fd, bk, rt, lt,

        pencolor, color, pensize, width,
        fillcolor, begin_fill, end_fill,

        goto: goto_,
        circle,
        dot,

        speed,
        tracer,

        Screen,
        bgcolor,

        home,
        clear: clear_,
        hideturtle,
        showturtle
      });

      runBtn.disabled = false;
      toggleLinesBtn.disabled = false;
      statusEl.textContent = "Ready";
    } catch (e){
      statusEl.textContent = "Failed to load Python";
      errEl.textContent = String(e);
      console.error(e);
    }
  }

  // ---------- Run handler ----------
  runBtn.onclick = async () => {
    statusEl.textContent = "Running…";
    errEl.textContent = "";
    outEl.textContent = "";

    try{
      resetTurtle(true);
      queue = [];

      pyodide.runPython(`
import sys, importlib, js
_t = importlib.import_module("cc_turtle")
sys.modules["turtle"] = _t

def update():
    _t.update()
    js._cc_flush()

def clear():
    _t.clear()
    js._cc_flush()

_t.update = update
_t.clear = clear

globals().update({
  "update": update,
  "clear": clear,

  "forward": _t.forward,
  "backward": _t.backward,
  "back": _t.back,
  "fd": _t.fd,
  "bk": _t.bk,
  "left": _t.left,
  "right": _t.right,
  "lt": _t.lt,
  "rt": _t.rt,
  "goto": _t.goto,
  "home": _t.home,

  "penup": _t.penup,
  "pendown": _t.pendown,
  "pu": _t.pu,
  "pd": _t.pd,

  "pencolor": _t.pencolor,
  "color": _t.color,
  "pensize": _t.pensize,
  "width": _t.width,
  "fillcolor": _t.fillcolor,
  "begin_fill": _t.begin_fill,
  "end_fill": _t.end_fill,

  "circle": _t.circle,
  "dot": _t.dot,

  "speed": _t.speed,
  "tracer": _t.tracer,

  "Screen": _t.Screen,
  "bgcolor": _t.bgcolor,

  "hideturtle": _t.hideturtle,
  "showturtle": _t.showturtle,
})
      `.trim());

      await pyodide.runPythonAsync(editor.getValue());

      statusEl.textContent = "Drawing…";
      await runQueue(false);

      statusEl.textContent = "Done";
    } catch (e){
      statusEl.textContent = "Error";
      errEl.textContent = String(e);
      console.error(e);
    }
  };

  resetTurtle(false);
  main();
</script>
</body>
</html>
