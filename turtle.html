<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Cadets Turtle</title>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

  <style>
    body { margin:0; padding:14px; font-family:system-ui; }
    h3 { margin:0 0 12px 0; }
    #layout > div, #layout > canvas { min-width: 0; }

    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; }
      canvas { width: 100%; height: auto; }
    }

    #layout {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
    }

    textarea {
      width: 100%;
      height: 280px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      padding: 12px;
      border-radius: 12px;
      box-sizing: border-box;

      /* Dark editor look */
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #1e293b;
      caret-color: #38bdf8;
    }

    textarea::selection { background: #2563eb; color: white; }
    textarea:focus { outline: none; border-color: #38bdf8; }

    canvas { background:#fff; border:1px solid #ccc; border-radius:10px; }

    button {
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      cursor:pointer;
    }
    button.secondary { border:1px solid #999; background:#fff; color:#111; }
    button:disabled { opacity:0.5; cursor:not-allowed; }

    #toolbar { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; align-items:center; }
    #status { font-size:14px; }

    .panelTitle { font-size: 12px; margin: 10px 0 6px 0; color: #374151; }

    pre {
      white-space: pre-wrap;
      background: #ffffff;
      color: #111111;
      padding: 10px;
      border-radius: 10px;
      margin: 0;
      min-height: 90px;
      border: 1px solid #d1d5db;
    }
    pre.err { background: #fff6f6; color: #7f1d1d; border: 1px solid #f0c0c0; }
  </style>
</head>

<body>
  <h3>Code Cadets - Python Turtle</h3>

  <div id="layout">
    <div>
     <textarea id="code" spellcheck="false">from turtle import *</textarea>
      <div id="toolbar">
        <button id="run" disabled>Run</button>
        <button id="clearCanvas" class="secondary">Clear canvas</button>
        <button id="clearOut" class="secondary">Clear output</button>
        <span id="status">Loading Python…</span>
      </div>

      <div class="panelTitle">Output</div>
      <pre id="out"></pre>

      <div class="panelTitle">Errors</div>
      <pre id="err" class="err"></pre>
    </div>

    <canvas id="canvas" width="520" height="520"></canvas>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const errEl = document.getElementById("err");

  const runBtn = document.getElementById("run");
  const clearCanvasBtn = document.getElementById("clearCanvas");
  const clearOutBtn = document.getElementById("clearOut");
  const codeEl = document.getElementById("code");

  // ---------- Output wiring ----------
  const appendOut = (t) => { outEl.textContent += String(t); };
  const setErr = (t) => { errEl.textContent = String(t || ""); };

  clearOutBtn.onclick = () => { outEl.textContent = ""; setErr(""); };

  // ---------- Turtle state ----------
  const cx = () => canvas.width / 2;
  const cy = () => canvas.height / 2;

  let x = cx();
  let y = cy();
  let angle = 0;       // degrees, 0 = right, 90 = up
  let penDown = true;

  let penColor = "#000000";
  let fillColor = "#000000";
  let penSize = 2;

  let isFilling = false;

  // Background / screen
  let bgColor = "#ffffff";

  // Animation controls
  let delayMs = 10;          // base delay for animation
  let tracerN = 1;           // turtle.tracer(n, delay) - if n==0, we still keep minimal animation
  let tracerDelayMs = null;

  // If tracer(0,0) is used, many tutorials call update() to show frames.
  // We'll respect update() as a "flush marker" by inserting an UPDATE command into the queue.
  let queue = [];

  function applyCanvasBackground(){
    // fill background first, then drawings occur above it
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function resetTurtle(keepBg = true){
    x = cx(); y = cy(); angle = 0; penDown = true;
    penColor = "#000000"; fillColor = "#000000"; penSize = 2; isFilling = false;

    delayMs = 10; tracerN = 1; tracerDelayMs = null;
    queue = [];

    if (!keepBg) bgColor = "#ffffff";

    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;

    // redraw background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    applyCanvasBackground();
  }

  function clearCanvasAll(){
    // "Clear canvas" button: reset everything including background
    bgColor = "#ffffff";
    resetTurtle(true);
  }

  clearCanvasBtn.onclick = () => { clearCanvasAll(); };

  // ---------- Queue helpers ----------
  function q(type, value){ queue.push([type, value]); }

  // Turtle API (queued)
  function update(){ q("update"); }
  function hideturtle(){ q("noop"); }
  function showturtle(){ q("noop"); }

  function forward(dist){ q("forward", Number(dist) || 0); }
  function backward(dist){ q("forward", -(Number(dist) || 0)); }
  function back(dist){ backward(dist); } // important alias

  function left(deg){ q("left", Number(deg) || 0); }
  function right(deg){ q("right", Number(deg) || 0); }

  function penup(){ q("penup"); }
  function pendown(){ q("pendown"); }

  // Aliases commonly used in tutorials
  function pu(){ penup(); }
  function pd(){ pendown(); }
  function fd(d){ forward(d); }
  function bk(d){ backward(d); }
  function rt(a){ right(a); }
  function lt(a){ left(a); }

  function pencolor(c){ q("pencolor", c); }
  function color(c){ q("pencolor", c); }
  function pensize(s){ q("pensize", Number(s) || 1); }
  function width(s){ q("pensize", Number(s) || 1); }

  function fillcolor(c){ q("fillcolor", c); }
  function begin_fill(){ q("begin_fill"); }
  function end_fill(){ q("end_fill"); }

  function goto_(tx, ty){ q("goto", [Number(tx) || 0, Number(ty) || 0]); }

  // dot(size=None, color=None)
  function dot(size, c){
    q("dot", {
      size: (size === undefined || size === null) ? 10 : Number(size) || 10,
      color: (c === undefined || c === null) ? null : c
    });
  }

  // bgcolor(color)
  function bgcolor(c){ q("bgcolor", c); }

  // circle(radius, extent=360, steps=None)
  function circle(radius, extent, steps){
    q("circle", {
      radius: Number(radius) || 0,
      extent: (extent === undefined) ? 360 : Number(extent) || 0,
      steps: (steps === undefined || steps === null) ? null : (Number(steps) || null),
    });
  }

  function speed(s){ q("speed", Number(s)); }

  function tracer(n, d){
    q("tracer", {
      n: (n === undefined || n === null) ? 1 : Number(n),
      delay: (d === undefined || d === null) ? null : Number(d)
    });
  }

  function home(){ q("home"); }

  // clear() should behave like turtle.clear() (clears drawings but keeps settings/background)
  function clear_(){ q("clear"); }

  // Screen() minimal stub so code using Screen().bgcolor(...) doesn't crash
  function Screen(){
    return {
      bgcolor: (c) => bgcolor(c)
    };
  }

  // ---------- Coordinate helpers ----------
  function toCanvasX(tx){ return cx() + tx; }
  function toCanvasY(ty){ return cy() - ty; }

  function maybeDelay(stepIndex){
    // Keep visible animation even if tracer(0,0) is used
    const effectiveTracer = (tracerN === 0 ? 1 : tracerN);
    const effectiveDelay = (tracerDelayMs !== null) ? tracerDelayMs : delayMs;

    if (effectiveTracer > 1 && (stepIndex % effectiveTracer) !== 0) return Promise.resolve();
    if (!effectiveDelay || effectiveDelay <= 0) return Promise.resolve();
    return new Promise(r => setTimeout(r, effectiveDelay));
  }

  async function drawLineTo(nx, ny, stepIndex){
    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;

    if (penDown){
      if (isFilling){
        ctx.lineTo(nx, ny);
      } else {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nx, ny);
        ctx.stroke();
      }
    }

    x = nx; y = ny;
    await maybeDelay(stepIndex);
  }

  async function moveForwardAnimated(dist){
    const steps = Math.max(1, Math.min(4000, Math.round(Math.abs(dist))));
    const stepSize = dist / steps;

    for (let i = 1; i <= steps; i++){
      const rad = angle * Math.PI / 180;
      const nx = x + Math.cos(rad) * stepSize;
      const ny = y - Math.sin(rad) * stepSize;
      await drawLineTo(nx, ny, i);
    }
  }

  async function moveGotoAnimated(tx, ty){
    const nx = toCanvasX(tx);
    const ny = toCanvasY(ty);

    const dx = nx - x;
    const dy = ny - y;
    const dist = Math.hypot(dx, dy);

    const steps = Math.max(1, Math.min(4000, Math.round(dist)));
    const sx = dx / steps;
    const sy = dy / steps;

    for (let i = 1; i <= steps; i++){
      await drawLineTo(x + sx, y + sy, i);
    }
  }

  async function circleAnimated(spec){
    const radius = spec.radius || 0;
    const extent = (spec.extent === undefined) ? 360 : spec.extent;
    const steps = spec.steps;

    const n = (steps !== null && steps !== undefined)
      ? Math.max(4, Math.min(720, Math.round(steps)))
      : Math.max(24, Math.min(240, Math.round(Math.abs(extent) * 0.5)));

    const stepAngle = extent / n;
    const arcLen = (2 * Math.PI * Math.abs(radius)) * (Math.abs(stepAngle) / 360);

    const turnDir = (radius >= 0) ? 1 : -1;
    const dist = arcLen;

    for (let i = 1; i <= n; i++){
      await moveForwardAnimated(dist);
      angle += turnDir * stepAngle;
    }
  }

  function applySpeed(s){
    // Rough mapping: 0 fastest, 10 fast, 1 slow (but keep a minimum so kids see motion)
    const n = Number.isFinite(s) ? Math.max(0, Math.min(10, Math.round(s))) : 3;
    if (n === 0) delayMs = 2;
    else delayMs = Math.max(1, 32 - (n * 3));
  }

  // ---------- Queue runner ----------
  // Runs commands; if stopOnUpdate=true it stops right AFTER seeing an "update" marker.
  async function runQueue(stopOnUpdate){
    while (queue.length){
      const [type, value] = queue.shift();

      if (type === "noop") { /* nothing */ }

      else if (type === "update") {
        if (stopOnUpdate) return;
      }

      else if (type === "left") { angle += value; }
      else if (type === "right") { angle -= value; }
      else if (type === "penup") { penDown = false; }
      else if (type === "pendown") { penDown = true; }

      else if (type === "pencolor") { penColor = String(value ?? penColor); }
      else if (type === "fillcolor") { fillColor = String(value ?? fillColor); }
      else if (type === "pensize") { penSize = Math.max(1, Math.min(50, value || 1)); }

      else if (type === "speed") { applySpeed(value); }

      else if (type === "tracer") {
        const n = value?.n;
        const d = value?.delay;

        tracerN = (Number.isFinite(n) ? n : 1);
        tracerN = Math.max(0, Math.min(50, Math.round(tracerN)));

        tracerDelayMs = (d === null || d === undefined) ? null : Math.max(0, Math.min(2000, Math.round(d)));
      }

      else if (type === "begin_fill") {
        isFilling = true;
        ctx.beginPath();
        ctx.moveTo(x, y);
      }

      else if (type === "end_fill") {
        if (isFilling){
          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          if (penDown){
            ctx.lineWidth = penSize;
            ctx.strokeStyle = penColor;
            ctx.stroke();
          }
        }
        isFilling = false;
      }

      else if (type === "home") {
        await moveGotoAnimated(0, 0);
        angle = 0;
      }

      else if (type === "clear") {
        // turtle.clear(): clear drawings but keep background and pen settings
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        applyCanvasBackground();
        x = cx(); y = cy(); angle = 0;
        isFilling = false;
      }

      else if (type === "bgcolor") {
        bgColor = String(value ?? bgColor);
        // Apply immediately (like screen background)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        applyCanvasBackground();
      }

      else if (type === "goto") {
        const tx = value[0], ty = value[1];
        await moveGotoAnimated(tx, ty);
      }

      else if (type === "circle") {
        await circleAnimated(value);
      }

      else if (type === "forward") {
        await moveForwardAnimated(value);
      }

      else if (type === "dot") {
        const size = Math.max(1, Math.min(600, Number(value.size) || 10));
        const c = value.color;
        const oldFill = ctx.fillStyle;

        ctx.beginPath();
        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = (c === null || c === undefined) ? penColor : String(c);
        ctx.fill();

        ctx.fillStyle = oldFill;
        await maybeDelay(1);
      }
    }
  }

  // JS flush function that Python calls to show animation frames during tracer(0)/update loops
  window._cc_flush = async () => {
    // Run until first update marker, then stop (so update() controls frames)
    await runQueue(true);
  };

  // ---------- Pyodide boot + Python I/O ----------
  let pyodide = null;

  async function main(){
    try{
      statusEl.textContent = "Loading Python…";
      pyodide = await loadPyodide();

      // Output bridge
      window._cc_append = (s) => appendOut(String(s));
      window._cc_input = (promptText) => (window.prompt(String(promptText ?? "")) || "");

      // Redirect Python stdout/stderr + input()
      pyodide.runPython(`
import sys, js, builtins

class _CCWriter:
    def write(self, s): js._cc_append(s)
    def flush(self): pass

sys.stdout = _CCWriter()
sys.stderr = _CCWriter()

builtins.input = lambda prompt="": js._cc_input(prompt)
      `.trim());

      // Register turtle JS module
      pyodide.registerJsModule("cc_turtle", {
        // core
        update,
        forward, backward, back, left, right,
        penup, pendown, pu, pd, fd, bk, rt, lt,

        // styling + fill
        pencolor, color, pensize, width,
        fillcolor, begin_fill, end_fill,

        // positioning + shapes
        goto: goto_,
        circle,
        dot,

        // speed + tracer
        speed,
        tracer,

        // screen + background
        Screen,
        bgcolor,

        // misc
        home,
        clear: clear_,
        hideturtle,
        showturtle
      });

      runBtn.disabled = false;
      statusEl.textContent = "Ready";
    } catch (e){
      statusEl.textContent = "Failed to load Python";
      setErr(String(e));
      console.error(e);
    }
  }

  // ---------- Run handler ----------
  runBtn.onclick = async () => {
    statusEl.textContent = "Running…";
    setErr("");
    outEl.textContent = "";

    try{
      // reset drawing but keep background for this run
      resetTurtle(true);
      queue = [];

      // IMPORTANT: NO vars(_t) ANYWHERE.
      // We explicitly map names so from turtle import * works.
      pyodide.runPython(`
import sys, importlib, js
_t = importlib.import_module("cc_turtle")
sys.modules["turtle"] = _t

# Make update() create a frame boundary + flush queued work up to that point.
def update():
    _t.update()        # queue an "update" marker
    js._cc_flush()     # run until marker, then stop

# Make clear() queue a clear + flush so animations swap frames cleanly.
def clear():
    _t.clear()
    js._cc_flush()

# Publish our update/clear overrides into the turtle module
_t.update = update
_t.clear = clear

# Publish names into globals so tutorials can call forward(100) etc.
globals().update({
  # frame control
  "update": update,
  "clear": clear,

  # movement + aliases
  "forward": _t.forward,
  "backward": _t.backward,
  "back": _t.back,
  "fd": _t.fd,
  "bk": _t.bk,
  "left": _t.left,
  "right": _t.right,
  "lt": _t.lt,
  "rt": _t.rt,
  "goto": _t.goto,
  "home": _t.home,

  # pen control
  "penup": _t.penup,
  "pendown": _t.pendown,
  "pu": _t.pu,
  "pd": _t.pd,

  # styling
  "pencolor": _t.pencolor,
  "color": _t.color,
  "pensize": _t.pensize,
  "width": _t.width,
  "fillcolor": _t.fillcolor,
  "begin_fill": _t.begin_fill,
  "end_fill": _t.end_fill,

  # shapes
  "circle": _t.circle,
  "dot": _t.dot,

  # speed/tracer
  "speed": _t.speed,
  "tracer": _t.tracer,

  # screen/background
  "Screen": _t.Screen,
  "bgcolor": _t.bgcolor,

  # misc
  "hideturtle": _t.hideturtle,
  "showturtle": _t.showturtle,
})
      `.trim());

      // Run pupil code (it can call update()/clear() which flushes frames)
      await pyodide.runPythonAsync(codeEl.value);

      // After Python finishes, flush any remaining queued commands to the end
      statusEl.textContent = "Drawing…";
      await runQueue(false);

      statusEl.textContent = "Done";
    } catch (e){
      statusEl.textContent = "Error";
      setErr(String(e));
      console.error(e);
    }
  };

  // Start up
  resetTurtle(false);
  main();
</script>
</body>
</html>
