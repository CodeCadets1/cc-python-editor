<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Cadets Turtle</title>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

  <style>
    body { margin:0; padding:14px; font-family:system-ui; }
    h3 { margin:0 0 12px 0; }
    #layout > div, #layout > canvas { min-width: 0; }

    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; }
      canvas { width: 100%; height: auto; }
    }

    #layout {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
    }

    textarea {
      width: 100%;
      height: 280px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      padding: 12px;
      border-radius: 12px;
      box-sizing: border-box;
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #1e293b;
      caret-color: #38bdf8;
    }
    textarea::selection { background: #2563eb; color: white; }
    textarea:focus { outline: none; border-color: #38bdf8; }

    canvas { background:#fff; border:1px solid #ccc; border-radius:10px; }

    button {
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      cursor:pointer;
    }
    button.secondary { border:1px solid #999; background:#fff; color:#111; }
    button:disabled { opacity:0.5; cursor:not-allowed; }

    #toolbar { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; align-items:center; }
    #status { font-size:14px; }

    .panelTitle { font-size: 12px; margin: 10px 0 6px 0; color: #374151; }

    pre {
      white-space: pre-wrap;
      background: #ffffff;
      color: #111111;
      padding: 10px;
      border-radius: 10px;
      margin: 0;
      min-height: 90px;
      border: 1px solid #d1d5db;
    }
    pre.err { background: #fff6f6; color: #7f1d1d; border: 1px solid #f0c0c0; }
  </style>
</head>

<body>
  <h3>Code Cadets - Python Turtle</h3>

  <div id="layout">
    <div>
      <textarea id="code" spellcheck="false">from turtle import *

pencolor("black")
fillcolor("deepskyblue")

begin_fill()
for i in range(4):
    forward(120)
    left(90)
end_fill()

dot(50)

print("Done!")</textarea>

      <div id="toolbar">
        <button id="run" disabled>Run</button>
        <button id="clearCanvas" class="secondary">Clear canvas</button>
        <button id="clearOut" class="secondary">Clear output</button>
        <span id="status">Loading Python…</span>
      </div>

      <div class="panelTitle">Output</div>
      <pre id="out"></pre>

      <div class="panelTitle">Errors</div>
      <pre id="err" class="err"></pre>
    </div>

    <canvas id="canvas" width="520" height="520"></canvas>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const errEl = document.getElementById("err");

  const runBtn = document.getElementById("run");
  const clearCanvasBtn = document.getElementById("clearCanvas");
  const clearOutBtn = document.getElementById("clearOut");
  const codeEl = document.getElementById("code");

  // ---------- Output wiring ----------
  const appendOut = (t) => { outEl.textContent += String(t); };
  const setErr = (t) => { errEl.textContent = String(t || ""); };
  clearOutBtn.onclick = () => { outEl.textContent = ""; setErr(""); };

  // ---------- Canvas / turtle drawing state ----------
  const cx = () => canvas.width / 2;
  const cy = () => canvas.height / 2;

  // turtle coordinates (0,0) is centre
  let x = cx();
  let y = cy();
  let angle = 0;     // degrees, 0 = right, 90 = up
  let penDown = true;

  let penColor = "#000000";
  let fillColor = "#000000";
  let penSize = 2;

  let isFilling = false;

  // background
  let bgColor = "#ffffff";

  // animation controls
  let delayMs = 10;          // base delay
  let tracerN = 1;           // if >1, reduce pauses; if 0, we still keep a small delay so kids see movement
  let tracerDelayMs = null;  // optional delay override via tracer()

  function fillBackground(){
    ctx.save();
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  function resetTurtle(){
    x = cx();
    y = cy();
    angle = 0;
    penDown = true;
    penColor = "#000000";
    fillColor = "#000000";
    penSize = 2;
    isFilling = false;

    delayMs = 10;
    tracerN = 1;
    tracerDelayMs = null;

    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;
  }

  function clearCanvasHard(){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fillBackground();
    resetTurtle();
  }

  clearCanvasBtn.onclick = () => { clearCanvasHard(); };

  // ---------- Command queue (Option B: pupil code stays synchronous) ----------
  let queue = [];
  function q(type, value){ queue.push([type, value]); }

  // no-ops
  function update(){ q("noop"); }
  function hideturtle(){ q("noop"); }
  function showturtle(){ q("noop"); }

  // movement / turning
  function forward(dist){ q("forward", Number(dist) || 0); }
  function backward(dist){ q("forward", -(Number(dist) || 0)); }
  function left(deg){ q("left", Number(deg) || 0); }
  function right(deg){ q("right", Number(deg) || 0); }

  // pen control
  function penup(){ q("penup"); }
  function pendown(){ q("pendown"); }
  function pu(){ penup(); }
  function pd(){ pendown(); }
  function fd(d){ forward(d); }
  function bk(d){ backward(d); }
  function rt(a){ right(a); }
  function lt(a){ left(a); }

  // style
  function pencolor(c){ q("pencolor", c); }
  function color(c){ q("pencolor", c); }
  function pensize(s){ q("pensize", Number(s) || 1); }
  function width(s){ q("pensize", Number(s) || 1); }

  // fill
  function fillcolor(c){ q("fillcolor", c); }
  function begin_fill(){ q("begin_fill"); }
  function end_fill(){ q("end_fill"); }

  // background / Screen
  function bgcolor(c){ q("bgcolor", c); }

  // dot
  function dot(size, c){
    q("dot", {
      size: (size === undefined || size === null) ? 10 : Number(size) || 10,
      color: (c === undefined || c === null) ? null : String(c)
    });
  }

  // positioning
  function goto_(tx, ty){ q("goto", [Number(tx) || 0, Number(ty) || 0]); }

  // circle(radius, extent=360, steps=None)
  function circle(radius, extent, steps){
    q("circle", {
      radius: Number(radius) || 0,
      extent: (extent === undefined) ? 360 : Number(extent) || 0,
      steps: (steps === undefined || steps === null) ? null : (Number(steps) || null),
    });
  }

  // speed + tracer
  function speed(s){ q("speed", Number(s)); }
  function tracer(n, d){
    q("tracer", {
      n: (n === undefined || n === null) ? 1 : Number(n),
      delay: (d === undefined || d === null) ? null : Number(d)
    });
  }

  // clear (keep pen settings like turtle.clear())
  function clear_(){ q("clear"); }

  // home
  function home(){ q("home"); }

  // ---------- Helpers ----------
  function toCanvasX(tx){ return cx() + tx; }
  function toCanvasY(ty){ return cy() - ty; }

  function effectiveDelayForStep(stepIndex){
    // Even if tracer(0), keep a tiny delay so kids see drawing
    const effectiveTracer = (tracerN === 0 ? 1 : tracerN);
    const d = (tracerDelayMs !== null) ? tracerDelayMs : delayMs;

    if (effectiveTracer > 1 && (stepIndex % effectiveTracer) !== 0) return 0;
    return (d && d > 0) ? d : 0;
  }

  function sleep(ms){
    if (!ms) return Promise.resolve();
    return new Promise(r => setTimeout(r, ms));
  }

  async function drawLineTo(nx, ny, stepIndex){
    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;
    ctx.fillStyle = fillColor;

    if (penDown){
      if (isFilling){
        ctx.lineTo(nx, ny);
      } else {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nx, ny);
        ctx.stroke();
      }
    }

    x = nx; y = ny;
    await sleep(effectiveDelayForStep(stepIndex));
  }

  async function moveForwardAnimated(dist){
    const steps = Math.max(1, Math.min(2000, Math.round(Math.abs(dist))));
    const stepSize = dist / steps;

    for (let i = 1; i <= steps; i++){
      const rad = angle * Math.PI / 180;
      const nx = x + Math.cos(rad) * stepSize;
      const ny = y - Math.sin(rad) * stepSize;
      await drawLineTo(nx, ny, i);
    }
  }

  async function moveGotoAnimated(tx, ty){
    const nx = toCanvasX(tx);
    const ny = toCanvasY(ty);

    const dx = nx - x;
    const dy = ny - y;
    const dist = Math.hypot(dx, dy);
    const steps = Math.max(1, Math.min(2000, Math.round(dist)));
    const sx = dx / steps;
    const sy = dy / steps;

    for (let i = 1; i <= steps; i++){
      await drawLineTo(x + sx, y + sy, i);
    }
  }

  async function circleAnimated(spec){
    const radius = spec.radius || 0;
    const extent = (spec.extent === undefined) ? 360 : spec.extent;
    const steps = spec.steps;

    const n = (steps !== null && steps !== undefined)
      ? Math.max(4, Math.min(720, Math.round(steps)))
      : Math.max(24, Math.min(240, Math.round(Math.abs(extent) * 0.5)));

    const stepAngle = extent / n;
    const arcLen = (2 * Math.PI * Math.abs(radius)) * (Math.abs(stepAngle) / 360);

    const turnDir = (radius >= 0) ? 1 : -1;
    const dist = arcLen;

    for (let i = 1; i <= n; i++){
      await moveForwardAnimated(dist);
      angle += turnDir * stepAngle;
    }
  }

  function applySpeed(s){
    // match “feel”: 0 fastest, 10 fast, 1 slow
    const n = Number.isFinite(s) ? Math.max(0, Math.min(10, Math.round(s))) : 3;
    if (n === 0) delayMs = 2;               // keep visible
    else delayMs = Math.max(1, 34 - (n * 3));
  }

  // ---------- Run queued commands ----------
  async function runQueue(){
    for (const cmd of queue){
      const type = cmd[0];
      const value = cmd[1];

      if (type === "noop") { continue; }

      if (type === "left") { angle += value; continue; }
      if (type === "right") { angle -= value; continue; }
      if (type === "penup") { penDown = false; continue; }
      if (type === "pendown") { penDown = true; continue; }

      if (type === "pencolor") { penColor = String(value ?? penColor); continue; }
      if (type === "fillcolor") { fillColor = String(value ?? fillColor); continue; }
      if (type === "pensize") { penSize = Math.max(1, Math.min(80, value || 1)); continue; }

      if (type === "speed") { applySpeed(value); continue; }

      if (type === "tracer") {
        const n = value?.n;
        const d = value?.delay;
        tracerN = (Number.isFinite(n) ? n : 1);
        tracerN = Math.max(0, Math.min(50, Math.round(tracerN)));
        tracerDelayMs = (d === null || d === undefined) ? null : Math.max(0, Math.min(2000, Math.round(d)));
        continue;
      }

      if (type === "bgcolor") {
        bgColor = String(value ?? bgColor);
        // apply immediately (like Screen().bgcolor)
        fillBackground();
        continue;
      }

      if (type === "begin_fill") {
        isFilling = true;
        ctx.beginPath();
        ctx.moveTo(x, y);
        continue;
      }

      if (type === "end_fill") {
        if (isFilling){
          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          if (penDown){
            ctx.lineWidth = penSize;
            ctx.strokeStyle = penColor;
            ctx.stroke();
          }
        }
        isFilling = false;
        continue;
      }

      if (type === "dot") {
        const size = Math.max(1, Math.min(400, Number(value?.size) || 10));
        const c = value?.color ? String(value.color) : penColor;

        ctx.save();
        ctx.fillStyle = c;
        ctx.beginPath();
        ctx.arc(x, y, size/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // small pause so dot appears “in time” with drawings
        await sleep(effectiveDelayForStep(1));
        continue;
      }

      if (type === "home") {
        await moveGotoAnimated(0, 0);
        angle = 0;
        continue;
      }

      if (type === "clear") {
        // turtle.clear(): clear drawings but keep settings
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        fillBackground();
        x = cx(); y = cy(); angle = 0;
        isFilling = false;
        continue;
      }

      if (type === "goto") {
        const tx = value[0], ty = value[1];
        await moveGotoAnimated(tx, ty);
        continue;
      }

      if (type === "circle") {
        await circleAnimated(value);
        continue;
      }

      if (type === "forward") {
        await moveForwardAnimated(value);
        continue;
      }
    }

    queue = [];
  }

  // ---------- Pyodide boot + Python I/O ----------
  let pyodide = null;

  async function main(){
    try{
      statusEl.textContent = "Loading Python…";
      pyodide = await loadPyodide();

      // Output bridge
      window._cc_append = (s) => appendOut(String(s));
      window._cc_input = (promptText) => (window.prompt(String(promptText ?? "")) || "");

      // Redirect Python stdout/stderr + input()
      pyodide.runPython(`
import sys, js, builtins

class _CCWriter:
    def write(self, s): js._cc_append(s)
    def flush(self): pass

sys.stdout = _CCWriter()
sys.stderr = _CCWriter()

builtins.input = lambda prompt="": js._cc_input(prompt)
      `.trim());

      // Register turtle JS module
      pyodide.registerJsModule("cc_turtle", {
        // basics
        update, hideturtle, showturtle,
        forward, backward, left, right,
        penup, pendown, pu, pd, fd, bk, rt, lt,
        pencolor, color,
        pensize, width,
        fillcolor, begin_fill, end_fill,
        goto: goto_, circle,
        speed, tracer,
        clear: clear_, home,
        // extras
        dot, bgcolor
      });

      runBtn.disabled = false;
      statusEl.textContent = "Ready";
    } catch (e){
      statusEl.textContent = "Failed to load Python";
      setErr(String(e));
      console.error(e);
    }
  }

  // ---------- Run handler ----------
  runBtn.onclick = async () => {
    statusEl.textContent = "Running…";
    setErr("");
    outEl.textContent = "";

    try{
      // clear drawing but keep background (bgColor might be set by code)
      ctx.clearRect(0,0,canvas.width,canvas.height);
      fillBackground();
      resetTurtle();
      queue = [];

      // Make "turtle" imports point to our module, and support from turtle import *
      pyodide.runPython(`
import sys, importlib
_t = importlib.import_module("cc_turtle")
sys.modules["turtle"] = _t

# Provide Screen() with bgcolor support (enough for tutorials)
class _CCScreen:
    def bgcolor(self, c):
        _t.bgcolor(c)

def Screen():
    return _CCScreen()

globals().update({
  # screen/bg
  "Screen": Screen,
  "bgcolor": _t.bgcolor,

  # common turtle funcs
  "update": _t.update,
  "hideturtle": _t.hideturtle,
  "showturtle": _t.showturtle,

  "pu": _t.pu,
  "pd": _t.pd,
  "fd": _t.fd,
  "bk": _t.bk,
  "rt": _t.rt,
  "lt": _t.lt,

  "forward": _t.forward,
  "backward": _t.backward,
  "left": _t.left,
  "right": _t.right,

  "penup": _t.penup,
  "pendown": _t.pendown,

  "pencolor": _t.pencolor,
  "color": _t.color,
  "pensize": _t.pensize,
  "width": _t.width,

  "fillcolor": _t.fillcolor,
  "begin_fill": _t.begin_fill,
  "end_fill": _t.end_fill,

  "goto": _t.goto,
  "circle": _t.circle,
  "dot": _t.dot,

  "speed": _t.speed,
  "tracer": _t.tracer,

  "home": _t.home,
  "clear": _t.clear,
})
      `.trim());

      // Run pupil code (fills queue and prints)
      await pyodide.runPythonAsync(codeEl.value);

      // Draw queued commands with animation
      statusEl.textContent = "Drawing…";
      await runQueue();

      statusEl.textContent = "Done";
    } catch (e){
      statusEl.textContent = "Error";
      setErr(String(e));
      console.error(e);
    }
  };

  // Start up
  clearCanvasHard();
  main();
</script>
</body>
</html>
