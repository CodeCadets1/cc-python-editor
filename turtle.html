<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Code Cadets Turtle</title>

<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

<style>
body { margin:0; padding:14px; font-family:system-ui; }
h3 { margin:0 0 12px 0; }

#layout {
  display:grid;
  grid-template-columns: 1.4fr 1fr;
  gap:14px;
}

@media (max-width:900px){
  #layout { grid-template-columns:1fr; }
}

textarea{
  width:100%;
  height:280px;
  font-family:ui-monospace, monospace;
  background:#0f172a;
  color:#e5e7eb;
  border:1px solid #1e293b;
  border-radius:12px;
  padding:12px;
}

canvas{
  background:#fff;
  border:1px solid #ccc;
  border-radius:10px;
}

button{
  padding:8px 12px;
  border-radius:10px;
  border:1px solid #333;
  background:#111;
  color:#fff;
}

button.secondary{
  background:#fff;
  color:#111;
  border:1px solid #999;
}

pre{
  background:#fff;
  border:1px solid #d1d5db;
  border-radius:10px;
  padding:10px;
  min-height:80px;
}

pre.err{
  background:#fff6f6;
  border-color:#f0c0c0;
  color:#7f1d1d;
}
</style>
</head>

<body>
<h3>Code Cadets â€“ Python Turtle</h3>

<div id="layout">
  <div>
    <textarea id="code">from turtle import *

pensize(5)
pencolor("blue")

for i in range(4):
    forward(100)
    left(90)

print("Done!")</textarea>

    <div style="margin:10px 0">
      <button id="run" disabled>Run</button>
      <button id="clearCanvas" class="secondary">Clear canvas</button>
    </div>

    <pre id="out"></pre>
    <pre id="err" class="err"></pre>
  </div>

  <canvas id="canvas" width="520" height="520"></canvas>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const cx = () => canvas.width/2;
const cy = () => canvas.height/2;

let x=cx(), y=cy(), angle=0;
let penDown=true, penSize=2, penColor="#000", fillColor="#000";
let delayMs=10;
let manual=false;
let queue=[];

function reset(){
  x=cx(); y=cy(); angle=0;
  penDown=true; penSize=2;
  penColor="#000"; fillColor="#000";
  delayMs=10; manual=false;
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

document.getElementById("clearCanvas").onclick=reset;

function q(t,v){ queue.push([t,v]); }

function forward(d){ q("fd",Number(d)||0); }
function backward(d){ q("fd",-Number(d)||0); }
function back(d){ backward(d); }

function left(a){ q("lt",Number(a)||0); }
function right(a){ q("rt",Number(a)||0); }

function penup(){ q("pu"); }
function pendown(){ q("pd"); }
function pu(){ penup(); }
function pd(){ pendown(); }

function pensize(s){ q("ps",Number(s)||1); }
function pencolor(c){ q("pc",c); }
function color(c){ pencolor(c); }

function fillcolor(c){ q("fc",c); }
function begin_fill(){ q("bf"); }
function end_fill(){ q("ef"); }

function goto_(tx,ty){ q("go",[tx,ty]); }

function dot(s){ q("dot",Number(s)||10); }

function tracer(n,d){
  manual=(n===0);
  if(d!==undefined) delayMs=d;
}

function update(){ q("update"); }

async function move(dist){
  const steps=Math.max(1,Math.abs(dist));
  for(let i=0;i<steps;i++){
    const r=angle*Math.PI/180;
    const nx=x+Math.cos(r)*(dist/steps);
    const ny=y-Math.sin(r)*(dist/steps);
    if(penDown){
      ctx.strokeStyle=penColor;
      ctx.lineWidth=penSize;
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(nx,ny);
      ctx.stroke();
    }
    x=nx; y=ny;
    if(!manual) await new Promise(r=>setTimeout(r,delayMs));
  }
}

async function runQueue(){
  while(queue.length){
    const [t,v]=queue.shift();

    if(t==="fd") await move(v);
    else if(t==="lt") angle+=v;
    else if(t==="rt") angle-=v;
    else if(t==="pu") penDown=false;
    else if(t==="pd") penDown=true;
    else if(t==="ps") penSize=v;
    else if(t==="pc") penColor=String(v);
    else if(t==="fc") fillColor=String(v);
    else if(t==="bf"){ ctx.beginPath(); ctx.moveTo(x,y); }
    else if(t==="ef"){ ctx.fillStyle=fillColor; ctx.fill(); }
    else if(t==="go"){ await move(Math.hypot(v[0]-x,v[1]-y)); }
    else if(t==="dot"){
      ctx.fillStyle=penColor;
      ctx.beginPath();
      ctx.arc(x,y,v/2,0,Math.PI*2);
      ctx.fill();
    }
    else if(t==="update"){ manual=false; }
  }
}

let pyodide=null;

async function boot(){
  pyodide=await loadPyodide();

  pyodide.registerJsModule("cc_turtle",{
    forward, backward, back,
    left, right,
    penup, pendown, pu, pd,
    pensize, pencolor, color,
    fillcolor, begin_fill, end_fill,
    goto:goto_,
    dot,
    tracer, update
  });

  document.getElementById("run").disabled=false;
}

document.getElementById("run").onclick=async()=>{
  reset();
  queue=[];
  document.getElementById("out").textContent="";
  document.getElementById("err").textContent="";

  try{
    pyodide.runPython(`
import sys,importlib
_t=importlib.import_module("cc_turtle")
sys.modules["turtle"]=_t
globals().update(vars(_t))
`);
    await pyodide.runPythonAsync(document.getElementById("code").value);
    await runQueue();
  }catch(e){
    document.getElementById("err").textContent=String(e);
  }
};

boot();
</script>
</body>
</html>
