<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Cadets Turtle</title>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

  <style>
    body { margin:0; padding:14px; font-family:system-ui; }
    h3 { margin:0 0 12px 0; }

    #layout {
      display:grid;
      grid-template-columns:1.4fr 1fr;
      gap:14px;
    }

    @media (max-width:900px){
      #layout{ grid-template-columns:1fr; }
    }

    textarea{
      width:100%;
      height:300px;
      font-family:ui-monospace, monospace;
      background:#0f172a;
      color:#e5e7eb;
      padding:12px;
      border-radius:12px;
      border:1px solid #1e293b;
      caret-color:#38bdf8;
      font-size:14px;
    }

    canvas{
      background:white;
      border-radius:12px;
      border:1px solid #ccc;
    }

    button{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      cursor:pointer;
    }

    .secondary{
      background:#fff;
      color:#111;
      border:1px solid #999;
    }

    pre{
      background:#fff;
      color:#111;
      padding:10px;
      border-radius:10px;
      min-height:80px;
      border:1px solid #ddd;
    }

    pre.err{
      background:#fff6f6;
      color:#7f1d1d;
      border-color:#f0c0c0;
    }
  </style>
</head>

<body>
<h3>Code Cadets â€“ Python Turtle</h3>

<div id="layout">
  <div>
<textarea id="code" spellcheck="false">from turtle import *

pencolor("black")
fillcolor("deepskyblue")

begin_fill()
for i in range(4):
    forward(120)
    left(90)
end_fill()

dot(50)

print("Done!")</textarea>

<div style="margin:10px 0;">
  <button id="run" disabled>Run</button>
  <button id="clearCanvas" class="secondary">Clear canvas</button>
</div>

<pre id="out"></pre>
<pre id="err" class="err"></pre>
  </div>

  <canvas id="canvas" width="520" height="520"></canvas>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const cx = () => canvas.width/2;
const cy = () => canvas.height/2;

let x=cx(), y=cy(), angle=0;
let penDown=true;
let penColor="#000";
let fillColor="#000";
let penSize=2;

let isFilling=false;
let fillPts=null;

let delayMs=10;
let tracerN=1;
let manualUpdate=false;
let queue=[];

function q(t,v){ queue.push([t,v]); }

function forward(d){ q("forward",d); }
function backward(d){ q("forward",-d); }
function left(a){ q("left",a); }
function right(a){ q("right",a); }
function goto_(x,y){ q("goto",[x,y]); }

function penup(){ penDown=false; }
function pendown(){ penDown=true; }
function pu(){ penup(); }
function pd(){ pendown(); }

function pencolor_(c){ penColor=String(c); }
function pencolor(c){ q("pencolor",c); }
function fillcolor(c){ q("fillcolor",c); }

function pensize(s){ q("pensize",s); }

function begin_fill(){ q("begin_fill"); }
function end_fill(){ q("end_fill"); }

function dot(size){ q("dot",Number(size)||10); }

function tracer(n){ tracerN=n; manualUpdate=(n===0); }
function update(){ q("update"); }

function maybeDelay(i){
  if(manualUpdate) return Promise.resolve();
  return new Promise(r=>setTimeout(r,delayMs));
}

async function drawLine(nx,ny,i){
  ctx.strokeStyle=penColor;
  ctx.lineWidth=penSize;
  if(penDown){
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(nx,ny);
    ctx.stroke();
  }
  if(isFilling){
    if(!fillPts) fillPts=[[x,y]];
    fillPts.push([nx,ny]);
  }
  x=nx; y=ny;
  await maybeDelay(i);
}

async function runQueue(){
  for(const [t,v] of queue){
    if(t==="left") angle+=v;
    else if(t==="right") angle-=v;
    else if(t==="forward"){
      let steps=Math.abs(v);
      let step=v/steps;
      for(let i=0;i<steps;i++){
        let r=angle*Math.PI/180;
        await drawLine(x+Math.cos(r)*step,y-Math.sin(r)*step,i);
      }
    }
    else if(t==="goto"){
      let [tx,ty]=v;
      let nx=cx()+tx, ny=cy()-ty;
      let dx=nx-x, dy=ny-y;
      let steps=Math.hypot(dx,dy);
      let sx=dx/steps, sy=dy/steps;
      for(let i=0;i<steps;i++) await drawLine(x+sx,y+sy,i);
    }
    else if(t==="pencolor") penColor=v;
    else if(t==="fillcolor") fillColor=v;
    else if(t==="pensize") penSize=Math.max(1,v);
    else if(t==="begin_fill"){ isFilling=true; fillPts=[[x,y]]; }
    else if(t==="end_fill"){
      if(fillPts){
        ctx.fillStyle=fillColor;
        ctx.beginPath();
        ctx.moveTo(fillPts[0][0],fillPts[0][1]);
        fillPts.forEach(p=>ctx.lineTo(p[0],p[1]));
        ctx.closePath();
        ctx.fill();
      }
      isFilling=false; fillPts=null;
    }
    else if(t==="dot"){
      ctx.fillStyle=penColor;
      ctx.beginPath();
      ctx.arc(x,y,v/2,0,Math.PI*2);
      ctx.fill();
    }
  }
  queue=[];
}

let pyodide=null;
async function main(){
  pyodide=await loadPyodide();

  pyodide.runPython(`
import sys, js
sys.stdout=sys.stderr=type("",(),{"write":lambda self,s:js.out.textContent+=s,"flush":lambda self:None})()
`);

  pyodide.registerJsModule("cc_turtle",{
    forward,backward,left,right,
    goto:goto_,pu,pd,penup,pendown,
    pencolor:pencolor_,fillcolor,pensize,
    begin_fill,end_fill,dot,tracer,update
  });

  document.getElementById("run").disabled=false;
}

document.getElementById("run").onclick=async()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  x=cx(); y=cy(); angle=0;
  queue=[];
  pyodide.runPython(`
import importlib,sys
t=importlib.import_module("cc_turtle")
sys.modules["turtle"]=t
globals().update(t.__dict__)
`);
  await pyodide.runPythonAsync(code.value);
  await runQueue();
};

main();
</script>
</body>
</html>
